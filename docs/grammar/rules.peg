# docs/grammar/rules.peg
#
# PEG grammar for the Amino rule expression language.
# This grammar describes the irreducible minimum — the atoms and structural elements that are
# always present regardless of operator configuration. All operator-level parsing is driven by
# the Pratt (top-down operator precedence) parser's dynamic operator table, implemented in
# amino/rules/parser.py.

# Irreducible minimum — always present regardless of operator preset.
# The Pratt parser's nud/led dispatch handles operators dynamically.

rule     <- s* expr s* eof
expr     <- atom (op atom)*     # schematic; Pratt loop drives actual parsing

atom     <- grouped / func_call / variable / literal
grouped  <- '(' s* expr s* ')'
func_call  <- identifier '(' s* args s* ')'
args     <- (expr (s* ',' s* expr)*)?
variable <- identifier ('.' identifier)*
literal  <- string / float / integer / boolean / list_lit
list_lit <- '[' s* (literal (s* ',' s* literal)*)? s* ']'

string   <- "'" (!"'" .)* "'"
float    <- '-'? [0-9]+ '.' [0-9]+
integer  <- '-'? [0-9]+
boolean  <- ('true' / 'false') !id_cont
identifier <- [a-zA-Z_] id_cont*
id_cont  <- [a-zA-Z0-9_]
S        <- [ \t]+
s        <- [ \t]*
eof      <- !.

# Notes:
# - Keyword operator disambiguation: `identifier '('` is always a function call. `identifier`
#   in infix position (between two expressions, not followed by `(`) is a keyword operator
#   dispatch to the Pratt led table.
#
# - `and`, `or`, `not` are always present regardless of operator preset (they are part of the
#   irreducible minimum, not registered operators). Built-in binding powers:
#
#     or           ->  10
#     and          ->  20
#     not          ->  30  (prefix)
#     in, not in   ->  40
#     =, !=        ->  40
#     >, <, >=, <= ->  40
#
# - `float` is tried before `integer` so `600.0` is correctly parsed as Float, not Integer
#   followed by `.0`.
